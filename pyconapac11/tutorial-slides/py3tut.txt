.. -*- coding: utf-8 -*-
.. include:: <s5defs.txt>
.. |==>| unicode:: U+02794 .. thick rightwards arrow

=================
Python 3 Tutorial
=================

.. class:: center large

   | `APAC PyCon 2011`_

.. class:: center small

   | Senthil Kumaran


.. _APAC PyCon 2011: http://apac.pycon.org


Python Release Schedule
=======================

* 3.3   - Under Development at http://hg.python.org/cpython
* 3.2.1 - Mid June, 2011 - Georg Brandl
* 2.7.2 - Mid June, 2011 - Benjamin Peterson
* 3.1.4 - Mid June, 2011 - Benjamin Peterson
* 2.6.7 - 3 - June, 2011 - Barry Warsaw
* Windows Installers by Martin and Mac Installers by Ronald or Ned Deily.

Python3
=======

* Breaking from it's roots.
* Moving away from it's C Background.
* Modern Frameworks and Advanced Applications.
* Taking good points from Java and others.
* Fixing a lot of Language warts.


Numbers
=======

Python 2 had separate types for int and long. The int datatype was limited by
sys.maxint, which varied by platform but was usually 232-1. 

Python 3 has just one integer type, which behaves mostly like the old long type
from Python 2.


Integer Division
================

::

	>>> 11 / 2      
	5.5
	>>> 11 // 2  
	5

In Python 2, the / operator usually meant integer division.

Python 3, the / operator always means floating point division. 


Sets
====

Creating a set is easy.

::

	>>> a_set = {1}
	>>> a_set
	{1}

	# Empty set

	>>> not_sure = {}
	>>> type(not_sure)
	<class 'dict'>

Due to historical quirks carried over from Python 2, you can not create an
empty set with two curly brackets. This actually creates an empty dictionary,
not an empty set.

Empty Set
=========

Correct way is create a set object. Because `{}` is taking up for creating dict in python2.

::

	>>> a_set = set()
	>>> a_set
	set()
	>>> type(a_set)
	<class 'set'>
	>>> len(a_set)
	0


Dictionary Comprehensions
=========================

A dictionary comprehension is like a list comprehension, but it constructs a
dictionary instead of a list.

.. class:: small

::

	>>> metadata_dict = {f:os.stat(f for f in glob.glob('*test*.py')}
	>>> type(metadata_dict) 
	<class 'dict'>
	>>> list(metadata_dict.keys())

Dict Comprehensions - 2
=======================

Like list comprehensions, you can include an if clause in a dictionary
comprehension to filter the input sequence based on an expression which is
evaluated with each item.

.. class:: small

::

	>>> humansize_dict = >>> {os.path.splitext(f)[0]:humansize.approximate_size(meta.st_size) \     
	...                   for f, meta in metadata_dict.items() 
	...		      if meta.st_size > 6000}   


Set Comprehensions
==================

Not to be left out, sets have their own comprehension syntax as well.

::

	>>> {x ** 2 for x in a_set}
	{0, 1, 4, 81, 64, 9, 16, 49, 25, 36}
	>>> {x for x in a_set if x % 2 == 0}
	{0, 8, 2, 4, 6}
	>>> {2**x for x in range(10)}
	{32, 1, 2, 4, 8, 64, 128, 256, 16, 512}

Strings
=======

* We think, Text == characters and symbols on the computer screen.
* Computer Thinks, Text == Bits and Bytes.

Every piece of text you’ve ever seen on a computer screen is actually stored in
a particular character encoding.

Strings
=======

Whenever someone gives you a sequence of bytes — a file, a web page, whatever —
and claims it’s “text,” you need to know what character encoding they used so
you can decode the bytes into characters.


Enter Unicode
=============

Unicode is a system designed to represent every character from every language.
Unicode represents each letter, character, or ideograph as a 4-byte number.
Each number represents a unique character used in at least one of the world’s
languages.

There is a Unicode encoding that uses four bytes per character. It’s called
UTF-32, because 32 bits = 4 bytes. UTF-32 is a straightforward encoding; it
takes each Unicode character (a 4-byte number) and represents the character
with that same number. 

Unicode
=======

* Non-obvious disadvantages to both UTF-32 and UTF-16.
* Different computer systems store individual bytes in different ways. 
* Character U+4E2D could be stored in UTF-16 as either 4E 2D (big endian) or 2D 4E (little-endian).
* BOM - "Byte Order Mark"

UTF-8
=====

UTF-8 is a variable-length encoding system for Unicode.
That is, different characters take up a different number of bytes.

For ascii characters (A-Z) utf-8 uses just one byte per character. In fact, it
uses the exact same bytes; the first 128 characters (0–127) in utf-8 are
indistinguishable from ascii.

Because of bit twiddling, there are no byte-ordering issues. A document encoded
in utf-8 uses the exact same stream of bytes on any computer.

Unicode Example
===============

::

	>>> s = '深入 Python'
	>>> len(s)
	9
	>>> s[0] 
	'深'
	>>> s + ' 3'  
	'深入 Python 3'

Formatting
==========

::

	>>> "{0},{1}".format('hello', 'world') 

* There’s a lot going on here. 
* First, that’s a method call on a string literal.
* Second, the whole expression evaluates to a string. 
* Third, {0} and {1} are replacement fields are replaced with correct values.

Formatting
==========

* A lot is possible

::

	>>> si_suffixes
	['KB', 'MB', 'GB']
	>>> '1000{0[0]} = 1{0[1]}'.format(si_suffixes)
	'1000KB = 1MB'


Formatting
==========

* Passing a list, and accessing an item of the list by index (as in the previous example)
* Passing a dictionary, and accessing a value of the dictionary by key
* Passing a module, and accessing its variables and functions by name
* Passing a class instance, and accessing its properties and methods by name
* Any combination of the above

Strings vs Bytes
================

Bytes are bytes; characters are an abstraction. An immutable sequence of
Unicode characters is called a string. An immutable sequence of
numbers-between-0-and-255 is called a bytes object.

::

	>>> by = b'abcd\x65'
	>>> by
	b'abcde'
	>>> type(by)  
	<class 'bytes'>

Bytes
=====
::

	>>> len(by)
	5
	>>> by += b'\xff'
	>>> by
	b'abcde\xff'
	>>> len(by)     
	6
	>>> by[0]      
	97

Bytes
=====
::

	>>> by[0] = 102
	...
	TypeError: 'bytes' object does not support item assignment.

A bytes object is **immutable**; you can not assign individual bytes. If you
need to change individual bytes, you can either use string slicing and
concatenation operators (which work the same as strings), or you can convert
the bytes object into a bytearray object.

ByteArray
=========

::

	>>> by = b'abcd\x65'
	>>> barr = bytearray(by)
	>>> barr
	bytearray(b'abcde')
	>>> len(barr)
	5
	>>> barr[0] = 102

	>>> barr
	bytearray(b'fbcde')


Mixing Bytes with Strings
=========================

* The one thing you can never do is mix bytes and strings.
* Try it!


Bytes and Strings
=================

And here is the link between strings and bytes: bytes objects have a decode()
method that takes a character encoding and returns a string, and strings have
an encode() method that takes a character encoding and returns a bytes object.

Files Opening
=============

* We need to know in what encoding the bytes represented by the file are stored.
* We pass it to open function.

::

	a_file = open('examples/chinese.txt', encoding='utf-8')

Syntax and Library
==================

* Standard Library Re-organization.

Unicode String Literals
=======================

*python2*

* u'PapayaWhip' 
* ur'PapayaWhip\foo'

**python3**

* 'PapayaWhip'
* r'PapayaWhip\foo'

Unicode global function
=======================

*python2*

* unicode(anything)

**Python3**

* str(anything)


Unifying Long Integers and Integers
===================================

In Python 3, there is only one integer type, called int, which mostly behaves
like the long type in Python 2.

*python2*

* x = 1000000000000L	
* x = 0xFFFFFFFFFFFFL	
* long(x)			
* type(x) is long		
* isinstance(x, long)	

Unifying Long Integers and Integers
===================================

**Python 3**

* x = 1000000000000
* x = 0xFFFFFFFFFFFF
* int(x)
* type(x) is int
* isinstance(x, int)

Comparision
===========

*python2*

* if x <> y:	
* if x <> y <> z:	

**python3**

* if x != y:
* if x != y != z:


has_key dict
============

* Use 'in' operator instead of 'has_key' method.

*python2*

* a_dictionary.has_key('PapayaWhip')	
* a_dictionary.has_key(x) or a_dictionary.has_key(y)
* a_dictionary.has_key(x or y)		
* a_dictionary.has_key(x + y)		
* x + a_dictionary.has_key(y)

in operator
===========

**Python3**

* 'PapayaWhip' in a_dictionary
* x in a_dictionary or y in a_dictionary
* (x or y) in a_dictionary
* (x + y) in a_dictionary
* x + (y in a_dictionary)


Dictionary methods
==================

* Many diction methods such as keys(), items(), and values() return dynamic views.

*python2*

* a_dictionary.keys()	
* a_dictionary.items()	
* a_dictionary.iterkeys()	
* [i for i in a_dictionary.iter(a_dictionary.keys())
* min(a_dictionary.keys())

Dictionary methods
==================

**python3**

* list(a_dictionary.keys())
* list(a_dictionary.items())
* iter(a_dictionary.keys())
* [i for i in a_dictionary.keys()]
* min(a_dictionary.keys()) # no change

http
====

*python2*

* import httplib	
* import Cookie	
* import cookielib
* import BaseHTTPSimport, import SimpleHTTPServer, import CGIHttpServer

**python3**

* import http.cookies
* import http.cookiejar
* import http.server


urllib
======

*python2*

* import urllib
* import urllib2
* import urlparse
* import robotparser
* from urllib import FancyURLopener
* from urllib import urlencode
* from urllib2 import Request
* from urllib2 import HTTPError

urllib
======

**python3**

* import urllib.request, urllib.parse, urllib.error
* from urllib.parse import urlencode
* from urllib.error import HTTPError
* import urllib.robotparser
* import urllib.request import FancyURLopener
* import urllib.request import urlencode
* import urllib.request import Request
* import urllib.error import HTTPError


dbm
===

**Python 3**

* import dbm.ndbm
* import dbm.gnu
* import dbm.bsd
* import dbm.dumb

xmlrpc
======

*Python 2*

* import xmlrpclib
* import DocXMLRPCServer
* import SimpleXMLRPCServer
* import xmlrpc.server

**python3**

import xmlrpc.client

io module
=========

*python2*

try:
    import cStringIO as StringIO
except ImportError:
    import StringIO

**python3**

import io

pickle
======

*python2*

try:
    import cPickle as pickle
except ImportError:
    import pickle

**python3**

import pickle

modules
=======

*python2* |==>| **python3**

* import __builtin__	|==>| import builtins
* import copy_reg	|==>| import copyreg
* import Queue		|==>| import queue
* import SocketServer	|==>| import socketserver
* import ConfigParser	|==>| import configparser
* import repr		|==>| import reprlib
* import commands	|==>| import subprocess

next iterator method
====================

* Python3 has a global next function which takes iterator methods

* anIterator.next()	|==>| next(anIterator)
* a_function_that_returns_an_iterator().next()	|==>| next(a_function_that_returns_an_iterator())

filter global function
======================

*  In Python 3, the filter() function returns an iterator, not a list.

* filter(a_function, a_sequence) |==>| list(filter(a_function, a_sequence))

map returns iterator
====================

*  filter(), the map() function now returns an iterator. (In Python 2, it returned a list.)
* map(a_function, 'PapayaWhip')	|==>| list(map(a_function, 'PapayaWhip'))


functools.reduce
================

* The reduce() function has been removed from the global namespace and placed in the functools module.

::

	from functools import reduce
	reduce(a, b, c)

apply function
==============

* the apply() function no longer exists; you must use the asterisk notation.

*python2*

::

	apply(a_function, a_list_of_args)

**python3**

::

	a_function(*a_list_of_args)

Exception Catching Syntax
=========================

* ``except CatchSomeException as expobj:``

::

	try:
	    import mymodule
	except ImportError as e:
	    pass

Type module
===========

* The types module contained a variety of constants to help you determine the type of an object. 
* In Python 2, it contained constants for all primitive types like dict and int. 
* In Python 3, these constants have been eliminated; just use the primitive type name instead.


Iterator related
================

* No xrange, it is just range
* No xreadlines, just loop over file object
* No ``from itertools import izip, imap`` builtins would return iterators.

Metaclass syntax
================

*Python2*

class Whip:
    __metaclass__ = PapayaMeta

**python3**

class Whip(metaclass=PapayaMeta):
    pass

memory view object
==================

Python objects implemented in C can export a “buffer interface,” which allows
other Python code to directly read and write a block of memory. 

In Python 3, buffer() has been renamed to memoryview(). Representation of
object in memory.

Change to Super Syntax
======================

*python2*

::

	class Child(SomeBaseClass):
	    def __init__(self):
		super(Child, self).__init__()

**python3**

::

	class Child(SomeBaseClass):
	      def __init__(self):
		  super().__init__()

Relative imports
================

* All imports are absolute in Python3 (PEP 328)
* In order to refer to modules with the same package use relative import.

::

   from . import module_from_this_package
   from .. import module_from_parent
   from .currentmodule import Class
   from ..parentmodule import ParentClass


print function
==============

``python "Thank you"``

SyntaxError: print..

``print("Thank you")``


Interesting Modules - Collections
=================================

* collections module provides a high performance container datatype.

* The specialized containers provided in this module provide alternatives to Python's general purpose built-in containers, `dict`, `list`, `set`, and `tuple`. 
 
* In addition to containers, the collections module provides some ABCs (abstract base classes) that can be used to test whether a class provides a particular interface, for example, whether it is hashable or a mapping.


collections.Counter
===================

A counter tool is provided to support convenient and rapid tallies.
For example::

    >>> # Tally occurrences of words in a list
    >>> cnt = Counter()
    >>> for word in ['red', 'blue', 'red', 'green', 'blue', 'blue']:
    ...     cnt[word] += 1
    >>> cnt
    Counter({'blue': 3, 'red': 2, 'green': 1})

collections.Counter
===================

* Finding the most common words in Hamlet

::

    >>> import re
    >>> words = re.findall('\w+', open('hamlet.txt').read().lower())
    >>> Counter(words).most_common(10)
    [('the', 1143), ('and', 966), ('to', 762), ('of', 669), ('i', 631),
     ('you', 554),  ('a', 546), ('my', 514), ('hamlet', 471), ('in', 451)]


Namedtuple
==========

named tuples assign meaning to each position in a tuple and allow for more
readable, self-documenting code.  They can be used wherever regular tuples are
used, and they add the ability to access fields by name instead of position
index.

::

>>> from collections import namedtuple
>>> Point = namedtuple('Point', 'x y', verbose=True)
>>> pp = Point(10,20)
>>> print(pp.x, pp.y)

Network Programming
===================

* A minor diversion into network programming.
* socket_irclogger.py

Extending string formating
==========================

Python strings have a ``__format__`` magic method. There are ways to extend it
and have a desirable formatting of strings based on certain identifiers.

* Look at extend_string.py


total ordering
==============

* total_ordering.py

Instant Dynamic Programming
===========================

::

	@lru_cache(maxsize=None)
	def fib(n):
	    if n < 2:
		return n
	    return fib(n-1) + fib(n-2)

>>> print([fib(n) for n in range(16)])
[0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610]

>>> print(fib.cache_info())
CacheInfo(hits=28, misses=16, maxsize=None, currsize=16)

2to3
====

* Run ./2to3 to convert stdin (-), files or directories given as arguments.

* 2to3 must be run with at least Python 2.6. 

* The intended path for migrating to Python 3.x is to first migrate to 2.6 (in order to take advantage of Python 2.6’s runtime compatibility checks).

* Use example.py to try 2to3

Migration Strategies
====================

* Separate Branch for 3 and 2.
* Coding with tricks and lot of spaghetti.
* Using distribute and disutils effectively.
* Using 2 and 3 compatible code.

Case Study - chardet
====================

* http://chardet.feedparser.org/
* Encoding Detector package.

Case Study - urwid
==================

* http://excess.org/urwid/ - Console User Interface Library

* py3k conversion using `distribute`_

.. _distribute: http://pypi.python.org/pypi/distribute

General Points
==============

* Python3 is going to Stay.
* Easy to migrate your own code.
* Performance improvements are guarenteed.
