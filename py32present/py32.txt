.. -*- coding: utf-8 -*-
.. include:: <s5defs.txt>
.. |==>| unicode:: U+02794 .. thick rightwards arrow

========================
What's new in Python 3.2
========================

.. sidebar:: Contents
   :class: handout

   .. contents:: :local:

.. class:: center large

   | For Python Users Group, Singapore

.. class:: center small

   | **Senthil Kumaran**
   | orsenthil@gmail.com
   | http://www.uthcode.com

.. class:: handout

        What is coming up new in the Python 3.2 version.

        There are 3 versions of this presentation:

        * `S5 presentation <py32.html>`__
        * `Handout <py32handout.html>`__
        * `reStructuredText source <py32.txt>`__

        ©2010, licensed under a `Creative Commons
        Attribution/Share-Alike (BY-SA) license
        <http://creativecommons.org/licenses/by-sa/3.0/>`__.

Python 3.2 Release Schedule
===========================

* 3.2 beta 1: December 4, 2010. (Feature Freeze)
* 3.2 final: February 19, 2011  (Release Date)
* 3.2 Release Manager: Georg Brandl
* Binaries/Installers: Windows (Martin v. Loewis) and Mac (Ronald Oussoren)

*At the moment* 

::

        $python -q
        >>> import sys;sys.version
        '3.2rc3+ (py3k:88430M, Feb 17 2011, 14:53:19) \n[GCC 4.4.5]'


Python Language Moratorium
==========================

* Python 3.1 was released on June 27, 2009
* Disallows changes to syntax, semantics, and built-ins
* Language Moratorium to allow non-CPython implmentations to
  catchup.
* Help ease the adoption of Python 3.x and provide a more stable base.

.. class:: handout
        
        Here are list of issues which would be handled after moratorium. http://goo.gl/CCqDn

Defining a Stable ABI
=====================

* Python Extension modules were required to be rebuilt for each feature release
* Now, Extension modules can limit themselves to a limited APIs **Py_LIMITED_API**
* During the compilation of applications, the preprocessor macro Py_LIMITED_API
  must be defined. 
* There are list of GLOBALS, Functions available which fall under stable ABI. A definition file is made available.
* There is a converter module, which C source can use to convert itself to ABI compatible way.


.. class:: handout
      
         http://www.python.org/dev/peps/pep-0384/


import argparse
===============

* There is an argparse command line parsing module included in stdlib.
* That makes it 3. getopt,optparse and argparse. It was quite a discussion.
* argparse will be the future and optparse will slowly be deprecated.
* Support for positional args, sub-commands, **'required options'**, pattern for specifying and validating options.
* argparse has the ability to define subparsers, each with their own argument patterns and help displays:


.. class:: handout


        import argparse

        parser = argparse.ArgumentParser(
                    description = 'Manage servers',         # main description for help
                    epilog = 'Tested on Solaris and Linux') # displayed after help
        parser.add_argument('action',                       # argument name
                    choices = ['deploy', 'start', 'stop'],  # three allowed values
                    help = 'action on each target')         # help msg
        parser.add_argument('targets',
                    metavar = 'HOSTNAME',                   # var name used in help msg
                    nargs = '+',                            # require one or more targets
                    help = 'url for target machines')       # help msg explanation
        parser.add_argument('-u', '--user',                 # -u or --user option
                    required = True,                        # make it a required argument
                    help = 'login as user')

        print(parser.parse_args('-h'.split()))

logging module - Configuration Dictionary.
==========================================

* **logging.config.dictConfig()** - logging configuration with plain Python dictionaries.

::

        with open('conf.json', 'r') as f:
                conf = json.load(f)
        logging.config.dictConfig(conf)


from concurrent import futures
==============================

* Code for creating and managing concurrency is being collected in a new top-level namespace, concurrent
* first package is **futures** high level interface for managing threads and processes.
* Inspired by java.utils.concurrent and Future Object.
* status checks (running or done), timeouts, cancellations, adding callbacks, and access to results or exceptions


.. class:: handout

        The primary offering of the new module is a pair of executor classes
        for launching and managing calls. The goal of the executors is to make
        it easier to use existing tools for making parallel calls. They save
        the effort needed to setup a pool of resources, launch the calls,
        create a results queue, add time-out handling, and limit the total
        number of threads, processes, or remote procedure calls.

        Ideally, each application should share a single executor across
        multiple components so that process and thread limits can be centrally
        managed. This solves the design challenge that arises when each
        component has its own competing strategy for resource management.

        Both classes share a common interface with three methods: submit() for
        scheduling a callable and returning a Future object; map() for
        scheduling many asynchronous calls at a time, and shutdown() for
        freeing resources. The class is a context manager and can be used in a
        with statement to assure that resources are automatically released when
        currently pending futures are done executing.


pyc directories
===============
* Multiple implementations can refer to their own .pyc files.
* mymodule.cpython-32.pyc, mymodule.cpython-33.pyc, and mymodule.unladen10.pyc
* pyc files are now collected in a **__pycache__** directory stored under the package directory
* Imported modules now have a __cached__ attribute which stores the name of the actual file that was imported
* tag that is unique to each interpreter is accessible from the **imp** module

ABI version tagged .so 
======================

* shared object files by giving them a common directory and distinct names for each version
* common directory is “pyshared” and the file names are made distinct by identifying the Python implementation
* **/usr/share/pyshared/foo.cpython-32m.so**

WSGI 1.1
========

* Well Intentioned Upgrade for WSGI to support Python3.
* Informational PEP clarifies how bytes/text issues are to be handled by the WGSI protocol


String formatting sub-language
==============================

::

* Old string formatting had '#' type specifiers. It is included in the format sublanguage for compatiblity.

        >>> format(20, '#o')
        '0o24'
        >>> format(12.34, '#5.0f') # You can have leading space.
        '  12.'
        >>> format(1,'#%')  # percent operation
        '100.000000%'
        >>> format(1,'#.0%') # trailing dot.
        '100.%'
        >>> format(1,'.0%')
        '100%'

New string formatting methods
=============================

* **str.format_map** 
* It can take dictionaries from defaultdict, shelve, ConfigParser, dbm.

::

        >>> import shelve
        >>> d = shelve.open('tmp.shl')
        >>> 'The {project_name} status is {status} as of {date}'.format_map(d)
        'The testing project status is green as of February 15, 2011'

        >>> class PlaceholderDict(dict):
                def __missing__(self, key):
                    return '<{}>'.format(key)
        >>> 'Hello {name}, welcome to {location}'.format_map(PlaceholderDict())
        'Hello <name>, welcome to <location>'


Some environment Variables
==========================

* Warnings are now easier to control using the **PYTHONWARNINGS** environment variable as an alternative to using -W.
* **ResourceWarning**, has been added. It is emitted when potential issues with resource consumption or cleanup are detected.

::
        >>> f = open('foo','w')
        >>> del f
        __main__:1: ResourceWarning: unclosed file <_io.TextIOWrapper name='foo' mode='w' encoding='UTF-8'>


New methods on range
====================

::
        >>> range(0, 100, 2).count(10)
        1
        >>> range(0, 100, 2).index(10)
        5
        >>> range(0, 100, 2)[5]
        10
        >>> range(0, 100, 2)[0:5]
        range(0, 10, 2)

* Part of an effort to make more objects fully implement the **collections.Sequence** abstract base class

Slide-Heading
=============

* Point 1
* Point 2
* Point 3

::

        print('{0},{1}'.format('hello','world'))

.. class:: handout
        
        Handout Notes.

